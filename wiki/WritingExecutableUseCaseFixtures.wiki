#summary How to Write Executable Use Case Fixtures

= Introduction =

Spectacular has an engine for parsing a table composed of user action and expectations and finding methods with `Annotations` that match those actions and expectations.  This concept it based on the same behavior in the JBehave library.

Rather than be restricted to keywords such as Given/When/Then, you can use the english language to whatever limit you choose, in the format of traditional Use Cases.


=Details=

Writing Executable Use Cases under Spectacular isn't really very different than with JBehave.  Given a traditional use case table:

|| User Flow:  Logging In ||
|| *User Action* || *Expectation* || *Comments* ||
|| User navigates to home page || User sees home page with articles || ||
|| User clicks "login" link || User sees login page requesting credentials || ||
|| User enters credentials and submits form || User sees personalized page with articles || Alternative Flow: Logging In With Bad Credentials ||

Spectacular will parse the table and read the first two columns from left to right in each row below the headers, starting with `User navigates to home page`, then to `User sees home page with articles`, and so on.  Each step (called "Flow" and "Expectation") is searched for in annotated code.  When it finds a match, it executes that code and passes in any parameters, if applicable.

For the above example, you may define a class such as the following:


{{{

package minderupt.sample.euc;

import minderupt.spectacular.executor.euc.Context;

@EUC
public class SampleEUCFlows {

    @Flow("User navigates to home page")
    public void userNavigatesToHomePage() {
    
        // do something useful, like drive a browser

    }

    @Expectation("User sees home page with articles")
    public void userSeesPageWithArticles(Context context) {
        
       // Assert user sees page with articles

    }


    
}


}}}

*Couple things to take note:*

  * If you want your class methods to be searched when walking through a Use Case, annotate the class with `@EUC` (a marker annotation)
  * For each Flow step in the use case, annotate a method with `@Flow` with the value being some kind of expression that matches a flow step in your use case
  * For each Expectation step in the use case, annotate a method with `@Expectation` with the value being some kind of expression that matches an expectation step in your use case
  * If your @Flow/@Expectation either encounters an error or an expectation is not met, throw a checked or runtime exception - the exception and the value will be printed out in the test results

If you want to pull a value from the use case, you can enter a substitution variable in the @Flow/@Expectation annotation, like this:

|| User clicks "login" link || User sees login page requesting credentials || ||

{{{

    @Flow("User clicks \"${linkName}\" link")
    public void userClicksLink(String linkName) {
        // value of String linkName will be "login" (without quotes)
    }

}}}

Maintaining state within the class is *not* advisable, as there are no guarantees that the class which is instantiated for one step will be the same class used to execute the next step.  Also, as your tests grow in size, it would be good practice to separate your flow methods into like classes.  To pass state from one method to another, define a method with a `minderupt.spectacular.executor.euc.Context` object as the first parameter, followed by any other expected variables, like this:

|| User clicks "login" link || User sees login page requesting credentials || ||

{{{

    @Expectation("User sees ${pageName} page requesting credentials")
    public void userClicksLink(Context context, String linkName) {

        String someState = (String) context.get("someStateVar");
        // value of String linkName will be "login" (without quotes)
        // do something useful
        
        context.put("someOtherState", someVar);

    }

}}}

Common patterns are to pass around a Selenium variable in the Context.

If flow steps in the use case cannot be matched to any @Flow/@Expectation annotated method, or if the method encounters and error and throws an Exception, the rest of the Use Case will not be executed.

Example of an unmatched step:


|| User Flow:  Logging In ||
|| *User Action* || *Expectation* || *Comments* ||
|| User navigates to home page (SUCCESS)|| User sees home page with articles (SUCCESS)|| ||
|| User clicks "login" link (PENDING)|| User sees login page requesting credentials (NOT PERFORMED)|| ||
|| User enters credentials and submits form (NOT PERFORMED)|| User sees personalized page with articles (NOT PERFORMED)|| Alternative Flow: Logging In With Bad Credentials (NOT PERFORMED)|| ||


Example of an error during an expectation:

|| User Flow:  Logging In ||
|| *User Action* || *Expectation* || *Comments* ||
|| User navigates to home page (SUCCESS)|| User sees home page with articles (SUCCESS)|| ||
|| User clicks "login" link (SUCCESS)|| User sees login page requesting credentials (FAILURE) minderupt.sample.bdd.SomeException: User did not see login page as expected || ||
|| User enters credentials and submits form (NOT PERFORMED)|| User sees personalized page with articles (NOT PERFORMED)|| Alternative Flow: Logging In With Bad Credentials (NOT PERFORMED)|| ||


Possible result values include:

|| *Result Value* || *Definition* ||
|| (SUCCESS) || The use case flow/expectation was successful, no errors ||
|| (PENDING) || No matching flow/expectation executable method was found, rest of use case ignored ||
|| (FAILURE) || Method threw an exception during this step, rest of use case ignored ||
|| (NOT PERFORMED) || Each step after a (PENDING) or (FAILURE) is ignored and labeled accordingly ||



=Restrictions=




=Reference Material=

  * [http://jbehave.org JBehave]
  * [http://dannorth.net/introducing-bdd Introducing Behaviour Driven Development]
  * [http://cukes.info/ Cucumber] (Ruby implementation for writing Given-When-Then tests - hoping to support at some point in the future)